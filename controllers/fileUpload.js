const File = require("../models/File");
const cloudinary = require("cloudinary").v2;
// local file ka handler bnana hai
exports.localFileUpload = (req, res) => {
  console.log(__dirname);
  try {
    //fetch the file
    const file = req.files.file;
    console.log("FILE AA GYI -->", file);

    let path =
      __dirname + "/files/" + Date.now() + `.${file.name.split(".")[1]}`;
    console.log("PATH", path);

    file.mv(path, (err) => {
      console.log(err);
    });

    res.json({
      success: "true",
      message: "Local file uploaded successfully",
    });
  } catch (error) {
    console.log("Not able to upload the file on server");
    console.log(error);
  }
};

// The function takes two parameters: type and supportedTypes.
// type represents the file type that needs to be checked for support.
// supportedTypes is an array of supported file types.
// The function uses the includes() method on the supportedTypes array to check if the type parameter is included in the array.
// The includes() method returns true if the array contains the specified element (type), and false otherwise.
// The result of the includes() method is returned from the function.
// If the type is found in the supportedTypes array, the function will return true, indicating that the file type is supported.
// If the type is not found in the supportedTypes array, the function will return false, indicating that the file type is not supported.

function isFileTypeSupported(type, supportedTypes) {
  return supportedTypes.includes(type);
}

//The function is declared as async, which means it will run asynchronously and can use the await keyword to pause execution until a promise is resolved or rejected.
//The function takes three parameters: file, folder, and quality.
//file represents the file that needs to be uploaded to Cloudinary.
//folder is the destination folder on Cloudinary where the file will be stored.
//quality (optional) specifies the quality of the uploaded file.
//A variable named options is created, initialized with an object that has a single property folder, which is set to the value of the folder parameter.
//The console.log statement is used to print the temporary file path of the input file. This can be helpful for debugging purposes.
//If the quality parameter is provided (i.e., it is truthy), the options object is updated by adding a quality property with the value of the quality parameter.
// The options.resource_type property is set to "auto", which tells Cloudinary to automatically detect the resource type of the file being uploaded.
// The function then uses cloudinary.uploader.upload to upload the file to Cloudinary.
// This function takes two arguments: the path of the temporary file (file.tempFilePath) and the options object.
// The function call is awaited, which means the function will wait for the upload to complete before proceeding.
// The result of the upload operation is returned from the function.
//The file.tempFilePath passed as a parameter in the cloudinary.uploader.upload function represents the temporary file path of the file that is being uploaded to Cloudinary.
// In many cases, when working with file uploads, the uploaded file is first stored temporarily on the server before being processed or moved to its final destination. The file.tempFilePath is the path to this temporary file.
// The cloudinary.uploader.upload function expects the file path as the first argument, which is why file.tempFilePath is passed as the argument in this case. It tells Cloudinary where to find the file on the server and initiates the upload process.
// It's important to note that the file.tempFilePath value should be a valid file path pointing to the temporary file on the server's file system. This path is typically generated by a file upload library or framework and is specific to the server-side environment being used.

async function uploadFileToCloudinary(file, folder, quality) {
  const options = { folder };
  console.log("temp file path ", file.tempFilePath);

  if (quality) {
    options.quality = quality;
  }

  options.resource_type = "auto";
  return await cloudinary.uploader.upload(file.tempFilePath, options);
}
// image upload ka handler
exports.imageUpload = async (req, res) => {
  try {
    //data fetch kro
    const { name, tags, email } = req.body;
    const file = req.files.imageFile;

    //validation
    const supportedTypes = ["jpg", "jpeg", "png"];
    const fileType = file.name.split(".")[1].toLowerCase();

    if (!isFileTypeSupported(fileType, supportedTypes)) {
      return res.status(400).json({
        success: false,
        message: "File format not supported",
      });
    }

    const response = await uploadFileToCloudinary(file, "NewFolder");

    const fileData = await File.create({
      name,
      tags,
      email,
      imageUrl: response.secure_url,
    });

    res.json({
      success: true,
      imageUrl: response.secure_url,
      message: "Image Successfully Uploaded",
    });
  } catch (error) {
    console.error(error);
    res.status(400).json({
      success: false,
      message: "Something went wrong",
    });
  }
};

//video upload ka handler
exports.videoUpload = async (req, res) => {
  try {
    //data fetch kro
    const { name, tags, email } = req.body;
    const file = req.files.videoFile;

    //validation
    const supportedTypes = ["mp4", "mov"];
    const fileType = file.name.split(".")[1].toLowerCase();

    if (!isFileTypeSupported(fileType, supportedTypes)) {
      return res.status(400).json({
        success: false,
        message: "File format not supported",
      });
    }

    const response = await uploadFileToCloudinary(file, "NewFolder");

    const fileData = await File.create({
      name,
      tags,
      email,
      imageUrl: response.secure_url,
    });

    res.json({
      success: true,
      imageUrl: response.secure_url,
      message: "Video Successfully Uploaded",
    });
  } catch (error) {
    console.error(error);
    res.status(400).json({
      success: false,
      message: "Something went wrong",
    });
  }
};

//image reduces ka handler
exports.imageSizeUploader = async (req, res) => {
  try {
    //data fetch kro
    const { name, tags, email } = req.body;
    const file = req.files.imageFile;

    //validation
    const supportedTypes = ["jpg", "jpeg", "png"];
    const fileType = file.name.split(".")[1].toLowerCase();

    if (!isFileTypeSupported(fileType, supportedTypes)) {
      return res.status(400).json({
        success: false,
        message: "File format not supported",
      });
    }

    const response = await uploadFileToCloudinary(file, "NewFolder");

    const fileData = await File.create({
      name,
      tags,
      email,
      imageUrl: response.secure_url,
    });

    res.json({
      success: true,
      imageUrl: response.secure_url,
      message: "Image Successfully Uploaded",
    });
  } catch (error) {
    console.error(error);
    res.status(400).json({
      success: false,
      message: "Something went wrong",
    });
  }
};



exports.videoSizeReducer = async (req, res) => {
  try {
    //data fetch kro
    const { name, tags, email } = req.body;
    const file = req.files.videoFile;

    //validation
    const supportedTypes = ["mov", "mp4"];
    const fileType = file.name.split(".")[1].toLowerCase();

    if (!isFileTypeSupported(fileType, supportedTypes)) {
      return res.status(400).json({
        success: false,
        message: "File format not supported",
      });
    }

    const response = await uploadFileToCloudinary(file, "NewFolder");

    const fileData = await File.create({
      name,
      tags,
      email,
      videoUrl: response.secure_url,
    });

    res.json({
      success: true,
      imageUrl: response.secure_url,
      message: "Video Successfully Uploaded",
    });
  } catch (error) {
    console.error(error);
    res.status(400).json({
      success: false,
      message: "Something went wrong",
    });
  }
};